# Agile Software Development: Refactoring
Refactoring for high-performance Agile Software Development. Refactoring for better code. Refactoring is about improving the quality of your code by simplifying your code. Simpler code enables agility, the ability to change your code quickly, to add new features, to meet people's ever changing needs.

I am using a test-driven development practice of writing tests first here. For a full understanding of what is it all about? And why is it important?
Please read this article [Test-Driven Development: Really, It's a Design Technique](https://www.infoq.com/articles/test-driven-design-java/).

***This repository hosts all 3 Java Magazine articles series source-code.***

## Here are what you are going to learn from these articles:
1. **Refactoring with New Code**
    1. Defining refactoring
    1. Setting up a TDD environment
    1. Renaming variables
    1. Using the inline and extract method
1. **Stabilizing Legacy Code**
    1. Pinning down legacy code
    1. Testing code and branch coverage
1. **Refactoring legacy code**
    1. Simplifying math and Booleans
    1. Adding new behaviors to refactored code

### The Legacy code Kata
The legacy code kata I used it here in these articles series is inspired from [**Gilded Rose Kata**, written by Emily Bache](https://github.com/emilybache/GildedRose-Refactoring-Kata).

## Link To Articles
1. [Refactoring Java, Part 1: Driving agile development with test-driven development](https://blogs.oracle.com/javamagazine/refactoring-java-part-1-driving-agile-development-with-test-driven-development).
1. [Refactoring Java, Part 2: Stabilizing your legacy code and technical debt](https://blogs.oracle.com/javamagazine/refactoring-java-part-2-stabilizing-your-legacy-code-and-technical-debt).
1. [Refactoring Java, Part 3: Regaining business agility by simplifying legacy code](https://blogs.oracle.com/javamagazine/refactoring-java-part-3-regaining-business-agility-by-simplifying-legacy-code).

## How it works? ðŸ¤”
Each article is divided into steps, and in each step, I have managed to have a git commit for each TDD *red-green-blue* change. So, when you navigate the commits, you can notice the differences, and the refactorings that has been done toward final Kata requirements.
